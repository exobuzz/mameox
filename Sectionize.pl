#!/bin/perl

# Auto generate an 8 character unique name for each file
local $autoNameNumber = 0;
local @newFILEs;
local @FILEs = `find ./MAME/src/drivers/*.c`;

use constant DATA_PREFIX  => 'D';
use constant CODE_PREFIX  => 'C';
use constant BSS_PREFIX   => 'B';
use constant CONST_PREFIX => 'K';


	# Create the imageblddbg.switch file
open( DBGPRELOADFILE, ">imageblddbg.switch" );
print DBGPRELOADFILE "/IN:\"Debug\\MAMEoX.exe\"\n";
print DBGPRELOADFILE "/OUT:\"Debug\\MAMEoX.xbe\"\n";
print DBGPRELOADFILE "/STACK:\"0x20000\"\n";
print DBGPRELOADFILE "/DEBUG\n";
print DBGPRELOADFILE "/LIMITMEM\n";
print DBGPRELOADFILE "/NOLOGO\n";
print DBGPRELOADFILE "/formatud\n";
print DBGPRELOADFILE "/testname:\"MAMEoX Util (Don't Run)\"\n";
print DBGPRELOADFILE "/testid:0x4D414D45\n";

open( PRELOADFILE, ">imagebld.switch" );
print DBGPRELOADFILE "/IN:\"Release\\MAMEoX.exe\"\n";
print DBGPRELOADFILE "/OUT:\"Release\\MAMEoX.xbe\"\n";
print PRELOADFILE "/STACK:\"0x20000\"\n";
print PRELOADFILE "/LIMITMEM\n";
print PRELOADFILE "/NOLOGO\n";
print PRELOADFILE "/formatud\n";
print PRELOADFILE "/testname:\"MAMEoX Util (Don't Run)\"\n";
print PRELOADFILE "/testid:0x4D414D45\n";


	# Create the Sections.h file
open( GENERATEDFILE, ">./MAMEoX/includes/Sections.h" );
print GENERATEDFILE "/**\n";
print GENERATEDFILE "  * \\file      Sections.h\n";
print GENERATEDFILE "  * \\brief     Registration of MAME files for creation and usage of XBOX\n";
print GENERATEDFILE "  *             loadable sections.\n";
print GENERATEDFILE "  *\n";
print GENERATEDFILE "  * \\note      This file is autogenerated via Sectionize.pl DO NOT EDIT!\n";
print GENERATEDFILE "  */\n";
print GENERATEDFILE "#pragma once\n";
print GENERATEDFILE "//= I N C L U D E S ====================================================\n";
print GENERATEDFILE "#include <XTL.h>\n";
print GENERATEDFILE "#ifdef __cplusplus\n";
print GENERATEDFILE "extern \"C\" {\n";
print GENERATEDFILE "#endif\n";
print GENERATEDFILE "#include \"osd_cpu.h\"\n";
print GENERATEDFILE "//= P R O T O T Y P E S ================================================\n";
print GENERATEDFILE "\n#ifdef _DEBUG\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "//	CheckDriverSectionRAM\n";
print GENERATEDFILE "//! \\brief    Prints the size of each driver/snd/vdeo segment\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void CheckDriverSectionRAM( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	CheckCPUSectionRAM\n";
print GENERATEDFILE "//! \\brief    Prints the size of each CPU segment\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void CheckCPUSectionRAM( void );\n";
print GENERATEDFILE "#endif\n\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "//	InitDriverSectionizer\n";
print GENERATEDFILE "//! \\brief    Initializes the DriverSectionizer subsystem\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void InitDriverSectionizer( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	TerminateDriverSectionizer\n";
print GENERATEDFILE "//! \\brief    Terminates the DriverSectionizer subsystem\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void TerminateDriverSectionizer( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadDriverSectionByName\n";
print GENERATEDFILE "//! \\brief    Loads the section associated with the passed name\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\param    DriverFileName - The name of the file whose section\n";
print GENERATEDFILE "//!                             should be loaded\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadDriverSectionByName( const char *DriverFileName );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadDriverSectionByName\n";
print GENERATEDFILE "//! \\brief    Unloads the section associated with the passed name\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\param    DriverFileName - The name of the file whose section\n";
print GENERATEDFILE "//!                             should be unloaded\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadDriverSectionByName( const char *DriverFileName );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadDriverSections\n";
print GENERATEDFILE "//! \\brief    Loads all of the driver sections\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadDriverSections( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadDriverSections\n";
print GENERATEDFILE "//! \\brief    Unloads all of the driver sections\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadDriverSections( void );\n";


print GENERATEDFILE "\n\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	InitCPUSectionizer\n";
print GENERATEDFILE "//! \\brief    Initializes the DriverSectionizer subsystem\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void InitCPUSectionizer( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	TerminateCPUSectionizer\n";
print GENERATEDFILE "//! \\brief    Terminates the DriverSectionizer subsystem\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void TerminateCPUSectionizer( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadCPUSectionByID\n";
print GENERATEDFILE "//! \\brief    Loads the section associated with the passed name\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\param    CPUID - The ID of the CPU whose section\n";
print GENERATEDFILE "//!                    should be loaded\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadCPUSectionByID( UINT32 CPUID );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadCPUSectionByID\n";
print GENERATEDFILE "//! \\brief    Unloads the section associated with the passed name\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\param    CPUID - The ID of the CPU whose section\n";
print GENERATEDFILE "//!                    should be loaded\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadCPUSectionByID( UINT32 CPUID );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadCPUSections\n";
print GENERATEDFILE "//! \\brief    Loads all of the CPU sections\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadCPUSections( void );\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadCPUSections\n";
print GENERATEDFILE "//! \\brief    Unloads all of the CPU sections\n";
print GENERATEDFILE "//!\n";
print GENERATEDFILE "//! \\return   BOOL - Operation status\n";
print GENERATEDFILE "//! \\retval   TRUE - success\n";
print GENERATEDFILE "//! \\return   FALSE - Failure\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadCPUSections( void );\n";
print GENERATEDFILE "#ifdef __cplusplus\n";
print GENERATEDFILE "} // End extern \"C\"\n";
print GENERATEDFILE "#endif\n";
close( GENERATEDFILE );


	# Create the DriverSections.cpp file
open( GENERATEDFILE, ">./MAMEoX/sources/DriverSections.cpp" );
print GENERATEDFILE "/**\n";
print GENERATEDFILE "  * \\file      DriverSections.cpp\n";
print GENERATEDFILE "  * \\brief     Registration of driver files for creation and usage of XBOX\n";
print GENERATEDFILE "  *             loadable sections\n";
print GENERATEDFILE "  *\n";
print GENERATEDFILE "  * \\note      This file is autogenerated via Sectionize.pl DO NOT EDIT!\n";
print GENERATEDFILE "  */\n\n";
print GENERATEDFILE "//= I N C L U D E S ====================================================\n";
print GENERATEDFILE "#include <Xtl.h>\n";
print GENERATEDFILE "#include <stdio.h>\n";
print GENERATEDFILE "#include <map>\n";
print GENERATEDFILE "#include <string>\n";
print GENERATEDFILE "#include \"MAMEoX.h\"\n";
print GENERATEDFILE "#include \"DebugLogger.h\"\n";
print GENERATEDFILE "extern \"C\" {\n";
print GENERATEDFILE "#include \"osd_cpu.h\"\n";
print GENERATEDFILE "}\n";
print GENERATEDFILE "//= D E F I N E S ======================================================\n";
print GENERATEDFILE "#define DATA_PREFIX      \"".DATA_PREFIX."\"\n";
print GENERATEDFILE "#define CODE_PREFIX      \"".CODE_PREFIX."\"\n";
print GENERATEDFILE "#define BSS_PREFIX       \"".BSS_PREFIX."\"\n";
print GENERATEDFILE "#define CONST_PREFIX     \"".CONST_PREFIX."\"\n";
print GENERATEDFILE "\n";
print GENERATEDFILE "//= G L O B A L = V A R S ==============================================\n";
print GENERATEDFILE "static std::map< std::string, std::string >  g_nameToSectionMap;\n\n";
print GENERATEDFILE "//= P R O T O T Y P E S ================================================\n";
print GENERATEDFILE "extern \"C\" static void RegisterDriverSectionNames( void );\n\n";
print GENERATEDFILE "//= F U N C T I O N S ==================================================\n";
print GENERATEDFILE "extern \"C\" {\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	InitDriverSectionizer\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void InitDriverSectionizer( void )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  g_nameToSectionMap.clear();\n";
print GENERATEDFILE "  void *addr;\n";
print GENERATEDFILE "  addr = XLoadSection( \"DRVSNIZE\" );\n";
print GENERATEDFILE "  if( !addr )\n";
print GENERATEDFILE "  {\n";
print GENERATEDFILE "    UINT32 lastErr = GetLastError();\n";
print GENERATEDFILE "    PRINTMSG( T_ERROR, \"XLoadSection failed! 0x%X\\r\\n\", lastErr );\n";
print GENERATEDFILE "  }\n";
print GENERATEDFILE "  RegisterDriverSectionNames();\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	TerminateDriverSectionizer\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void TerminateDriverSectionizer( void )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  g_nameToSectionMap.clear();\n";
print GENERATEDFILE "  XFreeSection( \"DRVSNIZE\" );\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "#pragma code_seg( \"DRVCSNZE\" )\n";
print GENERATEDFILE "#pragma data_seg( \"DRVDSNZE\" )\n";
print GENERATEDFILE "#pragma comment(linker, \"/merge:DRVCSNZE=DRVSNIZE\")\n";
print GENERATEDFILE "#pragma comment(linker, \"/merge:DRVDSNZE=DRVSNIZE\")\n";
print GENERATEDFILE "\n#ifdef _DEBUG\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "//	CheckDriverSectionRAM\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "void CheckDriverSectionRAM( void )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  DWORD total = 0;\n";
print GENERATEDFILE "  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();\n";
print GENERATEDFILE "  for( ; i != g_nameToSectionMap.end(); ++i )\n";
print GENERATEDFILE "  {\n";
print GENERATEDFILE "    HANDLE h = XGetSectionHandle( (*i).second.c_str() );\n";
print GENERATEDFILE "    if( h != INVALID_HANDLE_VALUE )\n";
print GENERATEDFILE "    {\n";
print GENERATEDFILE "      UINT32 sz = XGetSectionSize( h );\n";
print GENERATEDFILE "      PRINTMSG( T_INFO, \"Driver %s %lu\", (*i).first.c_str(), sz );\n";
print GENERATEDFILE "      total += sz;\n";
print GENERATEDFILE "    }\n";
print GENERATEDFILE "    else\n";
print GENERATEDFILE "      PRINTMSG( T_ERROR, \"Invalid section %s for file %s!\", (*i).second.c_str(), (*i).first.c_str() );\n";
print GENERATEDFILE "  }\n";
print GENERATEDFILE "  PRINTMSG( T_INFO, \"Total %lu bytes\\n\", total );\n";
print GENERATEDFILE "}\n";
print GENERATEDFILE "#endif\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	RegisterSectionName\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "static void RegisterSectionName( const char *DriverFileName, const char *sectionName )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "    // Add the section name to the map\n";
print GENERATEDFILE "  g_nameToSectionMap[ DriverFileName ] = sectionName;\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadDriverSectionByName\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadDriverSectionByName( const char *DriverFileName )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.find( DriverFileName );\n";
print GENERATEDFILE "  if( i == g_nameToSectionMap.end() )\n";
print GENERATEDFILE "    return FALSE;\n";
print GENERATEDFILE "  void *addr;\n";
print GENERATEDFILE "  PRINTMSG( T_INFO, \"Load section %s, ID %s\\n\", DriverFileName, (*i).second.c_str() );\n";
print GENERATEDFILE "  addr = XLoadSection( (*i).second.c_str() );\n";
print GENERATEDFILE "  if( !addr )\n";
print GENERATEDFILE "  {\n";
print GENERATEDFILE "    UINT32 lastErr = GetLastError();\n";
print GENERATEDFILE "    PRINTMSG( T_ERROR, \"XLoadSection failed! 0x%X\\r\\n\", lastErr );\n";
print GENERATEDFILE "    //osd_print_error( \"Failed to load section %s!\", (*i).second.c_str() );\n";
print GENERATEDFILE "    //return FALSE;\n";
print GENERATEDFILE "  }\n";
print GENERATEDFILE "  return TRUE;\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadDriverSectionByName\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadDriverSectionByName( const char *DriverFileName )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.find( DriverFileName );\n";
print GENERATEDFILE "  if( i == g_nameToSectionMap.end() )\n";
print GENERATEDFILE "    return FALSE;\n";
print GENERATEDFILE "  return XFreeSection( (*i).second.c_str() );\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	LoadDriverSections\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL LoadDriverSections( void )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();\n";
print GENERATEDFILE "  for( ; i != g_nameToSectionMap.end(); ++i )\n";
print GENERATEDFILE "  {\n";
print GENERATEDFILE "    if( !XLoadSection( (*i).second.c_str() ) )\n";
print GENERATEDFILE "    {\n";
print GENERATEDFILE "      PRINTMSG( T_ERROR, \"Failed to load section %s!\", (*i).second.c_str() );\n";
print GENERATEDFILE "      //return FALSE;\n";
print GENERATEDFILE "    }\n";
print GENERATEDFILE "  }\n";
print GENERATEDFILE "  return TRUE;\n";
print GENERATEDFILE "}\n\n";




print "Sectionizing drivers, sound hardware, and video hardware...\n";

#  LoadDriverSectionByName( "src\\drivers\\cps1.c" );      // cps2.c is dependent on cps1.c
#  LoadDriverSectionByName( "src\\drivers\\mpatrol.c" );   // 10 yard fight is dependent on the mpatrol vidhrdw
#  LoadDriverSectionByName( "src\\drivers\\snk.c" );       // hal121.c is dependent on snk vidhrdw (ASO - Armored Scrum Object)
#  LoadDriverSectionByName( "src\\drivers\\system16.c" );  // afterburner dependent
#  LoadDriverSectionByName( "src\\drivers\\galaxian.c" );  // Amidar
#  LoadDriverSectionByName( "src\\drivers\\scramble.c" );  // Amidar
#  LoadDriverSectionByName( "src\\drivers\\scobra.c" );    // Amidar
#  LoadDriverSectionByName( "src\\drivers\\rampart.c" );   // Arcade Classic Arcadecl.c
#  LoadDriverSectionByName( "src\\drivers\\williams.c" );  // Archrivals
#  LoadDriverSectionByName( "src\\drivers\\rastan.c" );    // Asuka & Asuka (sound)
#  LoadDriverSectionByName( "src\\drivers\\hal21.c" );     // Athena
#  LoadDriverSectionByName( "src\\drivers\\espial.c" );    // battle cruiser
#  LoadDriverSectionByName( "src\\drivers\\bzone.c" );     // gravitar
#  LoadDriverSectionByName( "src\\drivers\\nova2001.c" );  // Penguin-Kun War
#  LoadDriverSectionByName( "src\\drivers\\gottlieb.c" );  // exterminator
#  LoadDriverSectionByName( "src\\drivers\\pengo.c" );     // eyes
#  LoadDriverSectionByName( "src\\drivers\\megasys1.c" );  // F1 Grand Prix Star
#  LoadDriverSectionByName( "src\\drivers\\namcos1.c" );   // Face Off (Japan)
#  LoadDriverSectionByName( "src\\drivers\\rallyx.c" );    // Loco-Motion
#  LoadDriverSectionByName( "src\\drivers\\timeplt.c" );   // Loco-Motion
#  LoadDriverSectionByName( "src\\drivers\\exidy.c" );     // Victory
#  LoadDriverSectionByName( "src\\drivers\\m72.c" );       // Bomber Man World (World)
#  LoadDriverSectionByName( "src\\drivers\\leland.c" );    // Asylum (prototype)
#  LoadDriverSectionByName( "src\\drivers\\trackfld.c" );  // Hyper Sports, Hyper Olympics '84?
#  taito_f3 - Super Chase
#  multi32 - All sega system 32 games (Golden Axe 2)
#  namcoic, namcos2 - Lucky&Wild

@SkipDrivers = ( "jrcrypt.c", "mpatrol.c", "snk.c", 
                 "galaxian.c", "scramble.c", "scobra.c", 
	             "rampart.c", "williams.c", "rastan.c", "hal21.c", 
	             "espial.c", "bzone.c", "nova2001.c", "gottlieb.c", 
	             "pengo.c",  "megasys1.c", "rallyx.c", "timeplt.c", 
				 "exidy.c", "m72.c", "leland.c", "trackfld.c",
				 "taito_f3.c" );

@CapcomFamily = ( "cps1.c", "cps2.c" );

@NamcoFamily = ( "namcoic.c", "namcona1.c", "namconb1.c", "namcond1.c", "namcos1.c",
                 "namcos2.c", "namcos21.c", "namcos22.c", "namcos86.c" );

@SegaFamily = ( "multi32.c", "system1.c", "system16.c", "system18.c", "system24.c", "system32.c" );

local @Families = ( \@CapcomFamily, \@NamcoFamily, \@SegaFamily );
$autoNameNumber = $#Families + 10;


print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	UnloadDriverSections\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "BOOL UnloadDriverSections( void )\n";
print GENERATEDFILE "{\n";
print GENERATEDFILE "  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();\n";
print GENERATEDFILE "  for( ; i != g_nameToSectionMap.end(); ++i )\n";
print GENERATEDFILE "  {\n";
print GENERATEDFILE "      // Only unload families once (all but the first member are skipped)\n";
print GENERATEDFILE "    if( (*i).first == ";
local $IsFirst = true;
foreach( @Families ) {
	$FamilyArray = $_;
	foreach( @{$FamilyArray} ) {
			# Skip the first (key) member of the family
		if( $_ eq $FamilyArray->[0] ) {
			next;
		}

			# Print OR
		if( $IsFirst ne true ) {
			print GENERATEDFILE " ||\n        (*i).first == ";
		}
		$IsFirst = false;

			# Print code to ignore this member
		print GENERATEDFILE "\"src\\\\drivers\\\\$_\"";
	}
}
print GENERATEDFILE " )\n";
print GENERATEDFILE "        continue;\n";
print GENERATEDFILE "    XFreeSection( (*i).second.c_str() );\n";
print GENERATEDFILE "  }\n";
print GENERATEDFILE "  return TRUE;\n";
print GENERATEDFILE "}\n\n";
print GENERATEDFILE "\n//-------------------------------------------------------------\n";
print GENERATEDFILE "//	RegisterDriverSectionNames\n";
print GENERATEDFILE "//-------------------------------------------------------------\n";
print GENERATEDFILE "static void RegisterDriverSectionNames( void )\n";
print GENERATEDFILE "{\n";


# Do two passes, one to find the last autoNameNumber, another to actually
# modify the files
print "Pass 1...\n";

foreach( @FILEs ) {
	chomp( $_ );

	$DriverFileName = $_;

		# Change the DriverName to what will be present in the actual MAME code
		# Drop the ./MAME/ portion
	/^\.\/MAME\/src\/drivers\/(.*\.c)$/;
	$DriverNoPath = $1;
	$DriverName = "src\\\\drivers\\\\$1";
	$IsValid = true;

		# Skip the fake jrcrypt.c file and all the hack files
	foreach( @SkipDrivers ) {
		if( ($DriverNoPath eq $_ ) ) {
			print "Skipping $DriverNoPath.\n";
			$IsValid = false;
			last;
		}
	}

	next if( $IsValid eq false );


	$Family = false;
	$FamilyID = 0;
	foreach( @Families ) {
		$FamilyArray = $_;
		$FamilyID++;
		foreach( @{$FamilyArray} ) {
			if( ($DriverNoPath eq $_ ) ) {
				print "$DriverNoPath is in family $FamilyID.\n";
				$Family = $FamilyID;
				last;
			}
		}
	}



	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $DriverFileName );

	open( FILE, "<$DriverFileName" ) || die "Failed to open file $DriverFileName!\n";
	sysread( FILE, $File, $size );
	close( FILE );

	if( ($File =~ /\#pragma code_seg/) ) {
			# this should only happen on the first pass
		if( $Family ne false ) {
			print PRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
			print DBGPRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
			print GENERATEDFILE "  RegisterSectionName( \"$DriverName\", \"$Family\" );\n";
			$myAutoNameNumber = 0;	# Don't increment (families should always be less anyway)
		} else {
			$File =~ /\#pragma code_seg\(\"C(\d+)\"\)/;
			$myAutoNameNumber = $1;
			print PRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
			print DBGPRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
			print GENERATEDFILE "  RegisterSectionName( \"$DriverName\", \"$myAutoNameNumber\" );\n";
		}


		if( $myAutoNameNumber >= $autoNameNumber ) {
			$autoNameNumber = $myAutoNameNumber + 1;
		}		

	} else {
	   push @newFILEs, $DriverFileName;
	}
}


# Second pass, write out the section headers
print "Pass 2...\n";
foreach( @newFILEs ) {
	chomp( $_ );

	$DriverFileName = $_;

		# Change the DriverName to what will be present in the actual MAME code
		# Drop the ./MAME/ portion
	/^\.\/MAME\/src\/drivers\/(.*\.c)$/;
	$DriverNoPath = $1;
	$DriverName = "src\\\\drivers\\\\$1";
	$IsValid = true;

		# Skip the fake jrcrypt.c file and all the hack files
	foreach( @SkipDrivers ) {
		if( ($DriverNoPath eq $_ ) ) {
			print "Skipping $DriverNoPath.\n";
			$IsValid = false;
			last;
		}
	}

	next if( $IsValid eq false );

	$Family = false;
	$FamilyID = 0;
	foreach( @Families ) {
		$FamilyArray = $_;
		$FamilyID++;
		foreach( @{$FamilyArray} ) {
			if( ($DriverNoPath eq $_ ) ) {
				print "$DriverNoPath is in family $FamilyID.\n";
				$Family = $FamilyID;
				last;
			}
		}
	}

	if( $Family ne false ) {
		print PRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
		print DBGPRELOADFILE "/NOPRELOAD:\"$myAutoNameNumber\"\n";
		print GENERATEDFILE "  RegisterSectionName( \"$DriverName\", \"$Family\" );\n";
	} else {
		print PRELOADFILE "/NOPRELOAD:\"$autoNameNumber\"\n";
		print DBGPRELOADFILE "/NOPRELOAD:\"$autoNameNumber\"\n";
		print GENERATEDFILE "  RegisterSectionName( \"$DriverName\", \"$autoNameNumber\" );\n";
	}

	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $DriverFileName );

	open( FILE, "<$DriverFileName" ) || die "Failed to open file $DriverFileName!\n";
	sysread( FILE, $File, $size );
	close( FILE );

		# Write out the section header/footer
	if( $Family ne false ) {
		WriteSectionData( $DriverFileName, $File, $Family );
	} else {
		WriteSectionData( $DriverFileName, $File, $autoNameNumber );
	}

		# Also do the vidhdrw file, if one exists
	$VidHardwareName = $DriverFileName;
	$VidHardwareName =~ s/\/drivers\//\/vidhrdw\//;

	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $VidHardwareName );

	if( open( FILE, "<$VidHardwareName" ) ) {
		$File = "";
		sysread( FILE, $File, $size );
		close( FILE );

		if( !($File =~ /\#pragma code_seg/) ) {
			if( $Family ne false ) {
				WriteSectionData( $VidHardwareName, $File, $Family );
			} else {
				WriteSectionData( $VidHardwareName, $File, $autoNameNumber );
			}
		}
	}

		# Also do the sndhrdw file, if one exists
	$SoundHardwareName = $DriverFileName;
	$SoundHardwareName =~ s/\/drivers\//\/sndhrdw\//;

	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $SoundHardwareName );

	if( open( FILE, "<$SoundHardwareName" ) ) {
		$File = "";
		sysread( FILE, $File, $size );
		close( FILE );

		if( !($File =~ /\#pragma code_seg/) ) {
			if( $Family ne false ) {
				WriteSectionData( $SoundHardwareName, $File, $Family );
			} else {
				WriteSectionData( $SoundHardwareName, $File, $autoNameNumber );
			}
		}
	}

		# Also do the machine file, if one exists
	$MachineHardwareName = $DriverFileName;
	$MachineHardwareName =~ s/\/drivers\//\/machine\//;

	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $MachineHardwareName );

	if( open( FILE, "<$MachineHardwareName" ) ) {
		$File = "";
		sysread( FILE, $File, $size );
		close( FILE );

		if( !($File =~ /\#pragma code_seg/) ) {
			if( $Family ne false ) {
				WriteSectionData( $MachineHardwareName, $File, $Family );
			} else {
				WriteSectionData( $MachineHardwareName, $File, $autoNameNumber );
			}
		}
	}

	$autoNameNumber++;
}
print GENERATEDFILE "}\n";
print GENERATEDFILE "#pragma code_seg()\n";
print GENERATEDFILE "#pragma data_seg()\n";
print GENERATEDFILE "} // End extern \"C\"\n\n\n";
close( GENERATEDFILE );













#------------------------------------------------------------------------------


print "\n\nSectionizing CPU's...\n";

#local @CPUDirs = `find ./MAME/src/cpu -path \'*/CVS\' -prune -o -type d -a -print`;
@FILEs    = `find ./MAME/src/cpu/ -name *.c`;
@newFILEs = ();
local $OldCPUName = "";


@SkipCPUs = ( "DSP32", "I8085", "JAGUAR", "MIPS", "NEC", "PIC16C5X", "TMS9900" );

@MotorolaFamily = ( "M6502", "M6800", "M68000", "M6805", "M6809" );
@Families = ( \@MotorolaFamily );

$autoNameNumber = $#Families + 10;



	# Create the CPUSections.cpp file
open( CPUFILE, ">./MAMEoX/sources/CPUSections.cpp" );
print CPUFILE "/**\n";
print CPUFILE "  * \\file      CPUSections.cpp\n";
print CPUFILE "  * \\brief     Registration of CPU files for creation and usage of XBOX\n";
print CPUFILE "  *             loadable sections\n";
print CPUFILE "  *\n";
print CPUFILE "  * \\note      This file is autogenerated via Sectionize.pl DO NOT EDIT!\n";
print CPUFILE "  */\n\n";
print CPUFILE "//= I N C L U D E S ====================================================\n";
print CPUFILE "#include <Xtl.h>\n";
print CPUFILE "#include <stdio.h>\n";
print CPUFILE "#include <map>\n";
print CPUFILE "#include <string>\n";
print CPUFILE "#include \"MAMEoX.h\"\n";
print CPUFILE "#include \"DebugLogger.h\"\n";
print CPUFILE "extern \"C\" {\n";
print CPUFILE "#include \"osd_cpu.h\"\n";
print CPUFILE "#include \"cpuintrf.h\"\n";
print CPUFILE "}\n";
print CPUFILE "//= D E F I N E S ======================================================\n";
print CPUFILE "#define DATA_PREFIX      \"C".DATA_PREFIX."\"\n";
print CPUFILE "#define CODE_PREFIX      \"C".CODE_PREFIX."\"\n";
print CPUFILE "#define BSS_PREFIX       \"C".BSS_PREFIX."\"\n";
print CPUFILE "#define CONST_PREFIX     \"C".CONST_PREFIX."\"\n";
print CPUFILE "\n";
print CPUFILE "//= G L O B A L = V A R S ==============================================\n";
print CPUFILE "static std::map< UINT32, std::string >  g_IDToSectionMap;\n\n";
print CPUFILE "//= P R O T O T Y P E S ================================================\n";
print CPUFILE "extern \"C\" static void RegisterCPUSectionNames( void );\n\n";
print CPUFILE "//= F U N C T I O N S ==================================================\n";
print CPUFILE "extern \"C\" {\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	InitCPUSectionizer\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "void InitCPUSectionizer( void )\n";
print CPUFILE "{\n";
print CPUFILE "  g_IDToSectionMap.clear();\n";
print CPUFILE "  void *addr;\n";
print CPUFILE "  addr = XLoadSection( \"CPUSNIZE\" );\n";
print CPUFILE "  if( !addr )\n";
print CPUFILE "  {\n";
print CPUFILE "    UINT32 lastErr = GetLastError();\n";
print CPUFILE "    PRINTMSG( T_ERROR, \"XLoadSection failed! 0x%X\\r\\n\", lastErr );\n";
print CPUFILE "  }\n";
print CPUFILE "  RegisterCPUSectionNames();\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	TerminateCPUSectionizer\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "void TerminateCPUSectionizer( void )\n";
print CPUFILE "{\n";
print CPUFILE "  g_IDToSectionMap.clear();\n";
print CPUFILE "  XFreeSection( \"CPUSNIZE\" );\n";
print CPUFILE "}\n\n";
print CPUFILE "#pragma code_seg( \"CPUCSNZE\" )\n";
print CPUFILE "#pragma data_seg( \"CPUDSNZE\" )\n";
print CPUFILE "#pragma comment(linker, \"/merge:CPUCSNZE=CPUSNIZE\")\n";
print CPUFILE "#pragma comment(linker, \"/merge:CPUDSNZE=CPUSNIZE\")\n";
print CPUFILE "\n#ifdef _DEBUG\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "//	CheckCPUSectionRAM\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "void CheckCPUSectionRAM( void )\n";
print CPUFILE "{\n";
print CPUFILE "  DWORD total = 0;\n";
print CPUFILE "  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();\n";
print CPUFILE "  for( ; i != g_IDToSectionMap.end(); ++i )\n";
print CPUFILE "  {\n";
print CPUFILE "    HANDLE h = XGetSectionHandle( (*i).second.c_str() );\n";
print CPUFILE "    if( h != INVALID_HANDLE_VALUE )\n";
print CPUFILE "    {\n";
print CPUFILE "      UINT32 sz = XGetSectionSize( h );\n";
print CPUFILE "      PRINTMSG( T_INFO, \"CPU%lu %lu\", (*i).first, sz );\n";
print CPUFILE "      total += sz;\n";
print CPUFILE "    }\n";
print CPUFILE "    else\n";
print CPUFILE "      PRINTMSG( T_ERROR, \"Invalid section %s for CPU%lu!\", (*i).second.c_str(), (*i).first );\n";
print CPUFILE "  }\n";
print CPUFILE "  PRINTMSG( T_INFO, \"Total %lu bytes\\n\", total );\n";
print CPUFILE "}\n";
print CPUFILE "#endif\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	RegisterSectionID\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "static void RegisterSectionID( UINT32 CPUID, const char *DataSectionName )\n";
print CPUFILE "{\n";
print CPUFILE "    // Add the section name to the map\n";
print CPUFILE "  g_IDToSectionMap[ CPUID ] = DataSectionName;\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	LoadCPUSectionByID\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "BOOL LoadCPUSectionByID( UINT32 CPUID )\n";
print CPUFILE "{\n";
print CPUFILE "  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );\n";
print CPUFILE "  if( i == g_IDToSectionMap.end() )\n";
print CPUFILE "    return FALSE;\n";
print CPUFILE "  void *addr;\n";
print CPUFILE "  PRINTMSG( T_INFO, \"Load section CPU%lu, ID %s\\n\", CPUID, (*i).second.c_str() );\n";
print CPUFILE "  addr = XLoadSection( (*i).second.c_str() );\n";
print CPUFILE "  if( !addr )\n";
print CPUFILE "  {\n";
print CPUFILE "    UINT32 lastErr = GetLastError();\n";
print CPUFILE "    PRINTMSG( T_ERROR, \"XLoadSection failed for section %s! 0x%X\\r\\n\", (*i).second.c_str(), lastErr );\n";
print CPUFILE "  }\n";
print CPUFILE "  return TRUE;\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	UnloadCPUSectionByID\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "BOOL UnloadCPUSectionByID( UINT32 CPUID )\n";
print CPUFILE "{\n";
print CPUFILE "  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );\n";
print CPUFILE "  if( i == g_IDToSectionMap.end() )\n";
print CPUFILE "    return FALSE;\n";
print CPUFILE "  return XFreeSection( (*i).second.c_str() );\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	LoadCPUSections\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "BOOL LoadCPUSections( void )\n";
print CPUFILE "{\n";
print CPUFILE "  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();\n";
print CPUFILE "  for( ; i != g_IDToSectionMap.end(); ++i )\n";
print CPUFILE "  {\n";
print CPUFILE "    if( !XLoadSection( (*i).second.c_str() ) )\n";
print CPUFILE "    {\n";
print CPUFILE "      PRINTMSG( T_ERROR, \"Failed to load section %s!\", (*i).second.c_str() );\n";
print CPUFILE "      //return FALSE;\n";
print CPUFILE "    }\n";
print CPUFILE "  }\n";
print CPUFILE "  return TRUE;\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	UnloadCPUSections\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "BOOL UnloadCPUSections( void )\n";
print CPUFILE "{\n";
print CPUFILE "  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();\n";
print CPUFILE "  for( ; i != g_IDToSectionMap.end(); ++i )\n";
print CPUFILE "  {\n";
print CPUFILE "      // Only unload families once (all but the first member are skipped)\n";
print CPUFILE "    if( (*i).first == ";
local $IsFirst = true;
foreach( @Families ) {
	$FamilyArray = $_;
	foreach( @{$FamilyArray} ) {	
			# Skip the first (key) member of the family
		if( $_ eq $FamilyArray->[0] ) {
			next;
		}

			# Print OR
		if( $IsFirst ne true ) {
			print CPUFILE " ||\n        (*i).first == ";
		}
		$IsFirst = false;

			# Print code to ignore this member
		print CPUFILE "CPU_$_";
	}
}
print CPUFILE " )\n";
print CPUFILE "        continue;\n";
print CPUFILE "    XFreeSection( (*i).second.c_str() );\n";
print CPUFILE "  }\n";
print CPUFILE "  return TRUE;\n";
print CPUFILE "}\n\n";
print CPUFILE "\n//-------------------------------------------------------------\n";
print CPUFILE "//	RegisterCPUSectionNames\n";
print CPUFILE "//-------------------------------------------------------------\n";
print CPUFILE "static void RegisterCPUSectionNames( void )\n";
print CPUFILE "{\n";




# Do two passes, one to find the last autoNameNumber, another to actually
# modify the files
print "Pass 1...\n";

foreach( @FILEs ) {
	chomp( $_ );

	$DriverFileName = $_;
	$CPUName = $_;
		# Change the CPUName to what will be present in the actual code
		# Drop the ./MAME/src/cpu portion
	$CPUName =~ /^\.\/MAME\/src\/cpu\/(.+)\/.+\.c$/;
	$CPUName = $1;

	$IsValid = true;

		# Skip the fake jrcrypt.c file and all the hack files
	foreach( @SkipCPUs ) {
		$CPUToSkip = $_;
		if( uc($CPUName) eq $CPUToSkip ) {
			print "Skipping $CPUName.\n";
			$IsValid = false;
			last;
		}
	}

	$Family = false;
	$FamilyID = 0;
	foreach( @Families ) {
		$FamilyArray = $_;
		$FamilyID++;
		foreach( @{$FamilyArray} ) {			
			if( uc($CPUName) eq $_ ) {
				print "$CPUName is in family $FamilyID.\n";
				$Family = $FamilyID;
				last;
			}
		}
	}

	next if( $IsValid eq false );

	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $DriverFileName );

	open( FILE, "<$DriverFileName" ) || die "Failed to open file $DriverFileName!\n";
	sysread( FILE, $File, $size );
	close( FILE );

	if( ($File =~ /\#pragma code_seg/) ) {
			# this should only happen on the first pass
		$File =~ /\#pragma code_seg\(\"CC(\d+)\"\)/;
		$myAutoNameNumber = $1;

			# Unlike the drivers, we want one name for an entire directory
			# so only register on a new directory (CPUName)
		if( $CPUName ne $OldCPUName ) {
			$OldCPUName = $CPUName;
			$ucaseCPUName = uc( $CPUName );
			if( $Family ne false ) {
				print PRELOADFILE "/NOPRELOAD:\"C$Family\"\n";
				print DBGPRELOADFILE "/NOPRELOAD:\"C$Family\"\n";
				print CPUFILE "  RegisterSectionID( CPU_$ucaseCPUName, \"CPU$Family\" );\n";
				$myAutoNameNumber = 0;	# Don't increment (families should always be less anyway)
			}
			else {
				print PRELOADFILE "/NOPRELOAD:\"C$myAutoNameNumber\"\n";
				print DBGPRELOADFILE "/NOPRELOAD:\"C$myAutoNameNumber\"\n";
				print CPUFILE "  RegisterSectionID( CPU_$ucaseCPUName, \"CPU$myAutoNameNumber\" );\n";
			}
		}

		if( $myAutoNameNumber >= $autoNameNumber ) {
			$autoNameNumber = $myAutoNameNumber + 1;
		}
	} else {
		push @newFILEs, $DriverFileName;
	}
}

# Second pass, write out the section headers
print "Pass 2...\n";
$OldCPUName = "";

foreach( @newFILEs ) {
	chomp( $_ );

	$DriverFileName = $_;
	$CPUName = $_;
		# Change the CPUName to what will be present in the actual code
		# Drop the ./MAME/src/cpu portion
	$CPUName =~ /^\.\/MAME\/src\/cpu\/(.+)\/.+\.c$/;
	$CPUName = $1;

	$IsValid = true;

		# Skip the fake jrcrypt.c file and all the hack files
	foreach( @SkipCPUs ) {
		$CPUToSkip = $_;
		$CPUToSkip =~ s/\.c/\\.c/;
		if( ($CPUName =~ /.*$CPUToSkip/ ) ) {
			print "Skipping $CPUName.\n";
			$IsValid = false;
			last;
		}
	}

	$Family = false;
	$FamilyID = 0;
	foreach( @Families ) {
		$FamilyArray = $_;
		$FamilyID++;
		foreach( @{$FamilyArray} ) {			
			if( uc($CPUName) eq $_ ) {
				print "$CPUName is in family $FamilyID.\n";
				$Family = $FamilyID;
				last;
			}
		}
	}

	next if( $IsValid eq false );

		# Unlike the drivers, we want one name for an entire directory
		# so only register on a new directory (CPUName)
	if( $CPUName ne $OldCPUName ) {
		$OldCPUName = $CPUName;
		$ucaseCPUName = uc( $CPUName );
		if( $Family ne false ) {
			print PRELOADFILE "/NOPRELOAD:\"C$Family\"\n";
			print DBGPRELOADFILE "/NOPRELOAD:\"C$Family\"\n";
			print CPUFILE "  RegisterSectionID( CPU_$ucaseCPUName, \"CPU$Family\" );\n";
		} else {
			$autoNameNumber++;
			print PRELOADFILE "/NOPRELOAD:\"C$autoNameNumber\"\n";
			print DBGPRELOADFILE "/NOPRELOAD:\"C$autoNameNumber\"\n";
			print CPUFILE "  RegisterSectionID( CPU_$ucaseCPUName, \"CPU$autoNameNumber\" );\n";
		}
	}


	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat( $DriverFileName );

	open( FILE, "<$DriverFileName" ) || die "Failed to open file $DriverFileName!\n";
	sysread( FILE, $File, $size );
	close( FILE );

		# Write out the section header/footer
	if( $Family ne false ) {
		WriteCPUSectionData( $DriverFileName, $File, $Family );
	} else {
		WriteCPUSectionData( $DriverFileName, $File, $autoNameNumber );
	}
}

print CPUFILE "}\n";
print CPUFILE "#pragma code_seg()\n";
print CPUFILE "#pragma data_seg()\n";
print CPUFILE "} // End extern \"C\"\n\n\n";
close( CPUFILE );


close( PRELOADFILE );
close( DBGPRELOADFILE );



#------------------------------------------------------------------------
#	WriteSectionData
#------------------------------------------------------------------------
sub WriteSectionData( $$$ ) {
	my $FileName = $_[0];
	my $File = $_[1];
	my $autoNameNumber = $_[2];
	my $DataSectionName = "\"D$autoNameNumber\"";
	my $CodeSectionName = "\"C$autoNameNumber\"";
	my $BSSSectionName = "\"B$autoNameNumber\"";
	my $ConstSectionName= "\"K$autoNameNumber\"";

	open( FILE, ">$FileName" ) || die "Could not open $FileName for output!\n";

		#open the segment
	my $SegLine = "#pragma code_seg($CodeSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma data_seg($DataSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma bss_seg($BSSSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma const_seg($ConstSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );


		# Merge all of the sections into one segment (identified by $autoNameNumber)
		# Note: It is _very_ important to put the data section first, otherwise the
		#       merged section will be read-only!
	$SegLine = "#pragma comment(linker, \"/merge:D$autoNameNumber=$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:C$autoNameNumber=$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:B$autoNameNumber=$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:K$autoNameNumber=$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );


		#write the old file data
	syswrite( FILE, $File, $size );

		#Close the segment
	$SegLine = "#pragma code_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma data_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma bss_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma const_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );

	close( FILE );
}

#------------------------------------------------------------------------
#	WriteCPUSectionData
#------------------------------------------------------------------------
sub WriteCPUSectionData( $$$ ) {
	my $FileName = $_[0];
	my $File = $_[1];
	my $autoNameNumber = $_[2];
	my $CodeSectionName = "\"CC$autoNameNumber\"";
	my $DataSectionName = "\"CD$autoNameNumber\"";
	my $BSSSectionName = "\"CB$autoNameNumber\"";
	my $ConstSectionName= "\"CK$autoNameNumber\"";

	open( FILE, ">$FileName" ) || die "Could not open $FileName for output!\n";

		#open the segment
	my $SegLine = "#pragma code_seg($CodeSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma data_seg($DataSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma bss_seg($BSSSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma const_seg($ConstSectionName)\n";
	syswrite( FILE, $SegLine, length($SegLine) );

		# Merge all of the sections into one segment (identified by C$autoNameNumber)
		# Note: It is _very_ important to put the data section first, otherwise the
		#       merged section will be read-only!
	$SegLine = "#pragma comment(linker, \"/merge:CD$autoNameNumber=CPU$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:CC$autoNameNumber=CPU$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:CB$autoNameNumber=CPU$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma comment(linker, \"/merge:CK$autoNameNumber=CPU$autoNameNumber\")\n";
	syswrite( FILE, $SegLine, length($SegLine) );


		#write the old file data
	syswrite( FILE, $File, $size );

		#Close the segment
	$SegLine = "#pragma code_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma data_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma bss_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );
	$SegLine = "#pragma const_seg()\n";
	syswrite( FILE, $SegLine, length($SegLine) );

	close( FILE );
}
