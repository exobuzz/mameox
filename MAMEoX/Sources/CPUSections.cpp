/**
  * \file      CPUSections.cpp
  * \brief     Registration of CPU files for creation and usage of XBOX
  *             loadable sections
  *
  * \note      This file is autogenerated via Sectionize.pl DO NOT EDIT!
  */

//= I N C L U D E S ====================================================
#include <Xtl.h>
#include <stdio.h>
#include <map>
#include <string>
#include "MAMEoX.h"
#include "DebugLogger.h"
extern "C" {
#include "osd_cpu.h"
#include "cpuintrf.h"
}
//= D E F I N E S ======================================================
#define DATA_PREFIX      "CD"
#define CODE_PREFIX      "CC"
#define BSS_PREFIX       "CB"
#define CONST_PREFIX     "CK"

//= G L O B A L = V A R S ==============================================
static std::map< UINT32, std::string >  g_IDToSectionMap;

//= P R O T O T Y P E S ================================================
extern "C" static void RegisterCPUSectionNames( void );

//= F U N C T I O N S ==================================================
extern "C" {

//-------------------------------------------------------------
//	InitCPUSectionizer
//-------------------------------------------------------------
void InitCPUSectionizer( void )
{
  g_IDToSectionMap.clear();
  void *addr;
  addr = XLoadSection( "CPUSNIZE" );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
  }
  RegisterCPUSectionNames();
}


//-------------------------------------------------------------
//	TerminateCPUSectionizer
//-------------------------------------------------------------
void TerminateCPUSectionizer( void )
{
  g_IDToSectionMap.clear();
  XFreeSection( "CPUSNIZE" );
}

#pragma code_seg( "CPUCSNZE" )
#pragma data_seg( "CPUDSNZE" )
#pragma comment(linker, "/merge:CPUCSNZE=CPUSNIZE")
#pragma comment(linker, "/merge:CPUDSNZE=CPUSNIZE")

#ifdef _DEBUG
//-------------------------------------------------------------
//	CheckCPUSectionRAM
//-------------------------------------------------------------
void CheckCPUSectionRAM( void )
{
  DWORD total = 0;
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    HANDLE h = XGetSectionHandle( (*i).second.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU%lu %lu", (*i).first, sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for CPU%lu!", (*i).second.c_str(), (*i).first );
  }
  PRINTMSG( T_INFO, "Total %lu bytes\n", total );
}
#endif


//-------------------------------------------------------------
//	RegisterSectionID
//-------------------------------------------------------------
static void RegisterSectionID( UINT32 CPUID, const char *DataSectionName )
{
    // Add the section name to the map
  g_IDToSectionMap[ CPUID ] = DataSectionName;
}


//-------------------------------------------------------------
//	LoadCPUSectionByID
//-------------------------------------------------------------
BOOL LoadCPUSectionByID( UINT32 CPUID )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );
  if( i == g_IDToSectionMap.end() )
    return FALSE;
  void *addr;
  PRINTMSG( T_INFO, "Load section CPU%lu, ID %s\n", CPUID, (*i).second.c_str() );
  addr = XLoadSection( (*i).second.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed for section %s! 0x%X\r\n", (*i).second.c_str(), lastErr );
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUSectionByID
//-------------------------------------------------------------
BOOL UnloadCPUSectionByID( UINT32 CPUID )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );
  if( i == g_IDToSectionMap.end() )
    return FALSE;
  return XFreeSection( (*i).second.c_str() );
}


//-------------------------------------------------------------
//	LoadCPUSections
//-------------------------------------------------------------
BOOL LoadCPUSections( void )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    if( !XLoadSection( (*i).second.c_str() ) )
    {
      PRINTMSG( T_ERROR, "Failed to load section %s!", (*i).second.c_str() );
      //return FALSE;
    }
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUSections
//-------------------------------------------------------------
BOOL UnloadCPUSections( void )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
      // Only unload families once
    if( (*i).first == CPU_M6809 ||
        (*i).first == CPU_M6805 ||
        (*i).first == CPU_M68000 ||
        (*i).first == CPU_M6800 )
        continue;

    XFreeSection( (*i).second.c_str() );
  }
  return TRUE;
}


//-------------------------------------------------------------
//	RegisterCPUSectionNames
//-------------------------------------------------------------
static void RegisterCPUSectionNames( void )
{
  RegisterSectionID( CPU_Z8000, "CPU1" );
  RegisterSectionID( CPU_Z80, "CPU2" );
  RegisterSectionID( CPU_Z180, "CPU3" );
  RegisterSectionID( CPU_V60, "CPU4" );
  RegisterSectionID( CPU_UPD7810, "CPU5" );
  RegisterSectionID( CPU_TMS34010, "CPU6" );
  RegisterSectionID( CPU_TMS32031, "CPU7" );
  RegisterSectionID( CPU_TMS32025, "CPU8" );
  RegisterSectionID( CPU_TMS32010, "CPU9" );
  RegisterSectionID( CPU_T11, "CPU10" );
  RegisterSectionID( CPU_SH2, "CPU11" );
  RegisterSectionID( CPU_S2650, "CPU12" );
  RegisterSectionID( CPU_M6809, "CPU15" );
  RegisterSectionID( CPU_M6805, "CPU15" );
  RegisterSectionID( CPU_M68000, "CPU15" );
  RegisterSectionID( CPU_M6800, "CPU15" );
  RegisterSectionID( CPU_M6502, "CPU15" );
  RegisterSectionID( CPU_KONAMI, "CPU18" );
  RegisterSectionID( CPU_I8X41, "CPU19" );
  RegisterSectionID( CPU_I86, "CPU20" );
  RegisterSectionID( CPU_I8039, "CPU21" );
  RegisterSectionID( CPU_HD6309, "CPU22" );
  RegisterSectionID( CPU_H6280, "CPU23" );
  RegisterSectionID( CPU_CCPU, "CPU24" );
  RegisterSectionID( CPU_ASAP, "CPU25" );
  RegisterSectionID( CPU_ARM, "CPU26" );
  RegisterSectionID( CPU_ADSP2100, "CPU27" );
}
#pragma code_seg()
#pragma data_seg()
} // End extern "C"


