/**
  * \file      CPUSections.cpp
  * \brief     Registration of CPU files for creation and usage of XBOX
  *             loadable sections
  *
  * \note      This file is autogenerated via Sectionize.pl DO NOT EDIT!
  */

//= I N C L U D E S ====================================================
#include <Xtl.h>
#include <stdio.h>
#include <map>
#include <string>
#include "MAMEoX.h"
#include "DebugLogger.h"
extern "C" {
#include "osd_cpu.h"
#include "cpuintrf.h"
}
//= D E F I N E S ======================================================
#define DATA_PREFIX      "CD"
#define CODE_PREFIX      "CC"
#define BSS_PREFIX       "CB"
#define CONST_PREFIX     "CK"

//= G L O B A L = V A R S ==============================================
static std::map< UINT32, std::string >  g_IDToSectionMap;
//= F U N C T I O N S ==================================================
extern "C" {

#ifdef _DEBUG
//-------------------------------------------------------------
//	CheckCPUSectionRAM
//-------------------------------------------------------------
void CheckCPUSectionRAM( void )
{
  DWORD total = 0;
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = CODE_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU%lu [CODE]: %lu", (*i).first, sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for CPU%lu!", (*i).second.c_str(), (*i).first );

    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU%lu [DATA]: %lu", (*i).first, sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for CPU%lu!", (*i).second.c_str(), (*i).first );

    sectionName = BSS_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU%lu [BSS]: %lu", (*i).first, sz );
      total += sz;
    }
    else
    {
      PRINTMSG( T_ERROR, "Invalid section %s for CPU%lu!", (*i).second.c_str(), (*i).first );
    }

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU%lu [CONST]: %lu", (*i).first, sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for CPU%lu!", (*i).second.c_str(), (*i).first );

  }
  PRINTMSG( T_INFO, "Total %lu bytes\n", total );
}
#endif


//-------------------------------------------------------------
//	RegisterSectionID
//-------------------------------------------------------------
static void RegisterSectionID( UINT32 CPUID, const char *DataSectionName )
{
    // Add the section name to the map
  g_IDToSectionMap[ CPUID ] = DataSectionName;
}


//-------------------------------------------------------------
//	LoadCPUSectionByID
//-------------------------------------------------------------
BOOL LoadCPUSectionByID( UINT32 CPUID )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );
  if( i == g_IDToSectionMap.end() )
    return FALSE;
  std::string sectionName;
  void *addr;
  PRINTMSG( T_INFO, "Load section CPU%lu, ID %s\n", CPUID, (*i).second.c_str() );
  sectionName = DATA_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = CODE_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = BSS_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = CONST_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUSectionByID
//-------------------------------------------------------------
BOOL UnloadCPUSectionByID( UINT32 CPUID )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.find( CPUID );
  if( i == g_IDToSectionMap.end() )
    return FALSE;
  BOOL dataRet, codeRet, bssRet, constRet;
  std::string sectionName;
  sectionName = DATA_PREFIX;
  sectionName += (*i).second.c_str();
  dataRet = XFreeSection( sectionName.c_str() );

  sectionName = CODE_PREFIX;
  sectionName += (*i).second.c_str();
  codeRet = XFreeSection( sectionName.c_str() );

  sectionName = BSS_PREFIX;
  sectionName += (*i).second.c_str();
  bssRet = XFreeSection( sectionName.c_str() );

  sectionName = CONST_PREFIX;
  sectionName += (*i).second.c_str();
  constRet = XFreeSection( sectionName.c_str() );

  return (dataRet && codeRet && bssRet && constRet);
}


//-------------------------------------------------------------
//	LoadCPUDataSections
//-------------------------------------------------------------
BOOL LoadCPUDataSections( void )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    if( !XLoadSection( sectionName.c_str() ) )
    {
      PRINTMSG( T_ERROR, "Failed to load section %s!", sectionName.c_str() );
      //return FALSE;
    }

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    if( !XLoadSection( sectionName.c_str() ) )
    {
      PRINTMSG( T_ERROR, "Failed to load section %s!", sectionName.c_str() );
      //return FALSE;
    }
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUNonDataSections
//-------------------------------------------------------------
BOOL UnloadCPUNonDataSections( void )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = CODE_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

    sectionName = BSS_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUDataSections
//-------------------------------------------------------------
BOOL UnloadCPUDataSections( void )
{
  std::map< UINT32, std::string >::iterator i = g_IDToSectionMap.begin();
  for( ; i != g_IDToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );
  }
  return TRUE;
}


//-------------------------------------------------------------
//	RegisterCPUSectionNames
//-------------------------------------------------------------
void RegisterCPUSectionNames( void )
{
  RegisterSectionID( CPU_Z8000, "0" );
  RegisterSectionID( CPU_Z80, "1" );
  RegisterSectionID( CPU_Z180, "2" );
  RegisterSectionID( CPU_V60, "3" );
  RegisterSectionID( CPU_UPD7810, "4" );
  RegisterSectionID( CPU_TMS34010, "6" );
  RegisterSectionID( CPU_TMS32031, "7" );
  RegisterSectionID( CPU_TMS32025, "8" );
  RegisterSectionID( CPU_TMS32010, "9" );
  RegisterSectionID( CPU_T11, "10" );
  RegisterSectionID( CPU_SH2, "11" );
  RegisterSectionID( CPU_S2650, "12" );
  RegisterSectionID( CPU_M6809, "16" );
  RegisterSectionID( CPU_M6805, "17" );
  RegisterSectionID( CPU_M68000, "18" );
  RegisterSectionID( CPU_M6800, "19" );
  RegisterSectionID( CPU_M6502, "20" );
  RegisterSectionID( CPU_KONAMI, "21" );
  RegisterSectionID( CPU_I8X41, "23" );
  RegisterSectionID( CPU_I86, "24" );
  RegisterSectionID( CPU_I8039, "26" );
  RegisterSectionID( CPU_HD6309, "27" );
  RegisterSectionID( CPU_H6280, "28" );
  RegisterSectionID( CPU_CCPU, "30" );
  RegisterSectionID( CPU_ASAP, "31" );
  RegisterSectionID( CPU_ARM, "32" );
  RegisterSectionID( CPU_ADSP2100, "33" );
} // End extern "C"
}


