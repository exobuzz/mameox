/**
  * \file      CPUSections.cpp
  * \brief     Registration of CPU files for creation and usage of XBOX
  *             loadable sections
  *
  * \note      This file is autogenerated via Sectionize.pl DO NOT EDIT!
  */

//= I N C L U D E S ====================================================
#include <Xtl.h>
#include <stdio.h>
#include <map>
#include <string>
#include "MAMEoX.h"
#include "DebugLogger.h"
extern "C" {
#include "osd_cpu.h"
}
//= D E F I N E S ======================================================
#define DATA_PREFIX      "CD"
#define CODE_PREFIX      "CC"
#define BSS_PREFIX       "CB"
#define CONST_PREFIX     "CK"

//= G L O B A L = V A R S ==============================================
static std::map< std::string, std::string >  g_nameToSectionMap;
//= F U N C T I O N S ==================================================
extern "C" {

#ifdef _DEBUG
//-------------------------------------------------------------
//	CheckCPUSectionRAM
//-------------------------------------------------------------
void CheckCPUSectionRAM( void )
{
  DWORD total = 0;
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();
  for( ; i != g_nameToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = CODE_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU %s [CODE]: %lu", (*i).first.c_str(), sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for file %s!", (*i).second.c_str(), (*i).first.c_str() );

    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU %s [DATA]: %lu", (*i).first.c_str(), sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for file %s!", (*i).second.c_str(), (*i).first.c_str() );

    sectionName = BSS_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU %s [BSS]: %lu", (*i).first.c_str(), sz );
      total += sz;
    }
    else
    {
      PRINTMSG( T_ERROR, "Invalid section %s for file %s!", (*i).second.c_str(), (*i).first.c_str() );
    }

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
    {
      UINT32 sz = XGetSectionSize( h );
      PRINTMSG( T_INFO, "CPU %s [CONST]: %lu", (*i).first.c_str(), sz );
      total += sz;
    }
    else
      PRINTMSG( T_ERROR, "Invalid section %s for file %s!", (*i).second.c_str(), (*i).first.c_str() );

  }
  PRINTMSG( T_INFO, "Total %lu bytes\n", total );
}
#endif


//-------------------------------------------------------------
//	RegisterSectionName
//-------------------------------------------------------------
static void RegisterSectionName( const char *CPUFileName, const char *DataSectionName )
{
    // Add the section name to the map
  g_nameToSectionMap[ CPUFileName ] = DataSectionName;
}


//-------------------------------------------------------------
//	LoadCPUSectionByName
//-------------------------------------------------------------
BOOL LoadCPUSectionByName( const char *CPUFileName )
{
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.find( CPUFileName );
  if( i == g_nameToSectionMap.end() )
    return FALSE;
  std::string sectionName;
  void *addr;
  PRINTMSG( T_INFO, "Load section %s, ID %s\n", CPUFileName, (*i).second.c_str() );
  sectionName = DATA_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = CODE_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = BSS_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }

  sectionName = CONST_PREFIX;
  sectionName += (*i).second.c_str();
  addr = XLoadSection( sectionName.c_str() );
  if( !addr )
  {
    UINT32 lastErr = GetLastError();
    PRINTMSG( T_ERROR, "XLoadSection failed! 0x%X\r\n", lastErr );
    //osd_print_error( "Failed to load section %s!", sectionName.c_str() );
    //return FALSE;
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUSectionByName
//-------------------------------------------------------------
BOOL UnloadCPUSectionByName( const char *CPUFileName )
{
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.find( CPUFileName );
  if( i == g_nameToSectionMap.end() )
    return FALSE;
  BOOL dataRet, codeRet, bssRet, constRet;
  std::string sectionName;
  sectionName = DATA_PREFIX;
  sectionName += (*i).second.c_str();
  dataRet = XFreeSection( sectionName.c_str() );

  sectionName = CODE_PREFIX;
  sectionName += (*i).second.c_str();
  codeRet = XFreeSection( sectionName.c_str() );

  sectionName = BSS_PREFIX;
  sectionName += (*i).second.c_str();
  bssRet = XFreeSection( sectionName.c_str() );

  sectionName = CONST_PREFIX;
  sectionName += (*i).second.c_str();
  constRet = XFreeSection( sectionName.c_str() );

  return (dataRet && codeRet && bssRet && constRet);
}


//-------------------------------------------------------------
//	LoadCPUDataSections
//-------------------------------------------------------------
BOOL LoadCPUDataSections( void )
{
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();
  for( ; i != g_nameToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    if( !XLoadSection( sectionName.c_str() ) )
    {
      PRINTMSG( T_ERROR, "Failed to load section %s!", sectionName.c_str() );
      //return FALSE;
    }

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    if( !XLoadSection( sectionName.c_str() ) )
    {
      PRINTMSG( T_ERROR, "Failed to load section %s!", sectionName.c_str() );
      //return FALSE;
    }
  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUNonDataSections
//-------------------------------------------------------------
BOOL UnloadCPUNonDataSections( void )
{
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();
  for( ; i != g_nameToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = CODE_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

    sectionName = BSS_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

  }
  return TRUE;
}


//-------------------------------------------------------------
//	UnloadCPUDataSections
//-------------------------------------------------------------
BOOL UnloadCPUDataSections( void )
{
  std::map< std::string, std::string >::iterator i = g_nameToSectionMap.begin();
  for( ; i != g_nameToSectionMap.end(); ++i )
  {
    std::string sectionName;
    sectionName = DATA_PREFIX;
    sectionName += (*i).second.c_str();
    HANDLE h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );

    sectionName = CONST_PREFIX;
    sectionName += (*i).second.c_str();
    h = XGetSectionHandle( sectionName.c_str() );
    if( h != INVALID_HANDLE_VALUE )
      XFreeSectionByHandle( h );
  }
  return TRUE;
}


//-------------------------------------------------------------
//	RegisterCPUSectionNames
//-------------------------------------------------------------
void RegisterCPUSectionNames( void )
{
  RegisterSectionName( "z8000", "0" );
  RegisterSectionName( "z80", "1" );
  RegisterSectionName( "z180", "2" );
  RegisterSectionName( "v60", "3" );
  RegisterSectionName( "upd7810", "4" );
  RegisterSectionName( "tms9900", "5" );
  RegisterSectionName( "tms34010", "6" );
  RegisterSectionName( "tms32031", "7" );
  RegisterSectionName( "tms32025", "8" );
  RegisterSectionName( "tms32010", "9" );
  RegisterSectionName( "t11", "10" );
  RegisterSectionName( "sh2", "11" );
  RegisterSectionName( "s2650", "12" );
  RegisterSectionName( "pic16c5x", "13" );
  RegisterSectionName( "nec", "14" );
  RegisterSectionName( "mips", "15" );
  RegisterSectionName( "m6809", "16" );
  RegisterSectionName( "m6805", "17" );
  RegisterSectionName( "m68000", "18" );
  RegisterSectionName( "m6800", "19" );
  RegisterSectionName( "m6502", "20" );
  RegisterSectionName( "konami", "21" );
  RegisterSectionName( "jaguar", "22" );
  RegisterSectionName( "i8x41", "23" );
  RegisterSectionName( "i86", "24" );
  RegisterSectionName( "i8085", "25" );
  RegisterSectionName( "i8039", "26" );
  RegisterSectionName( "hd6309", "27" );
  RegisterSectionName( "h6280", "28" );
  RegisterSectionName( "dsp32", "29" );
  RegisterSectionName( "ccpu", "30" );
  RegisterSectionName( "asap", "31" );
  RegisterSectionName( "arm", "32" );
  RegisterSectionName( "adsp2100", "33" );
} // End extern "C"
}


